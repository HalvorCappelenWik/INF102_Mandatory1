# Semester assignment 1

This assignment has two sections. The first is a set of tasks similar to the labs, where you have to implement a small interface. The second contains a set of tasks where you need to implement code in a larger framework for *Robot Engineers*.

All code you submit will be evaluated on four points:
 - **Functional correctness**. Does the program do what it is supposed to do?
 - **Runtime**. Have you found an efficient solution to the program?
 - **Runtime analysis**. For each method you code you will need to add a comment about which Big-O runtime it has.
 - **Code quality**. Is you code readable and maintainable?

**IMPORTANT**: When implementing the code you must give a runtime analysis in [svar.md](svar.md).

# Section 1

### Task 1.1
Given a list of elements remove `k` random elements. 

In the repository you will find the interface `IRandomSelector` which contains two methods: 
 * `removeRandom(List<T> list)`. Remove a random element for the list.
 * `removeRandom(List<T> list, int k)`. Remove `k` random elements from the list.

**TODO: Implement these two methods in `MyRandomSelector.java`:**
```java
@Override
public <T> T removeRandom(List<T> list) {
	throw new UnsupportedOperationException();
}

@Override
public <T> List<T> removeRandom(List<T> list, int k) {
	throw new UnsupportedOperationException();
}
```
✅ Your code is functionally correct when `RandomSelectorTest` passes.

### Task 1.2
Given a list of elements select the `k` smallest. 
Given a list: `[6, 9, 12, 51, 3, -5, 7, -55, 125, 8]` and `k = 3`you need to fin `[-55, -5, 3]`.

In the repository you will find the interface `ISmallestSelector` which contains one method: `selectSmallest(List<T> list, int k, Comparator<? super T> comp)`. This method must return a collection of the `k` smallest elements in the list. `comp` is a comparator that determines how to order the elements. 

**TODO: Implement this method in `MySmallestSelector.java`:**
```java
@Override
public <T> Collection<T> selectSmallest(List<T> list, int k, Comparator<? super T> comp) {
   throw new UnsupportedOperationException();
}
```
✅ Your code is functionally correct when `SmallestSelectorTest` passes.


# Section 2
In this section you will implement code in an existing framework for *Robot Engineers*.

### Scenario
You are hired as a consultent at Automatic Robot Maintenance (ARM). They have many years of experience  in robot technology and cybernetics. Recently ARM landed a new contract for maintaining a large field of solar panels. Close to the solar panels there is a garbage disposal plant and some trash has a tendency to cover and dirty the solar panels, such that they do not produce any electricity. The company who owns the solar panels has constructed a system to detect if solar panels are recieving less light so that they can check for trash covering them. However, they have become tired of manually cleaning the solar panels and has therefore hired ARM to automate this task. The robots have been programmed to move on the solar panel field and to clean the solar panels, but currently it is taking too long to move the robots to where they need to be. 

ARM is in need of an algorithm to choose the correct robots to clean which solar panels and to position the robots so that they can execute a cleaning job as soon as the system detects one. ARM gets payed extra for each solar panel they clean, but lose money for each minute a solar panel is not operational due to being dirty.

### Online algorithm
This is what we call an online algorithm. You have to make choices based on the information you have in the moment and when future tasks arise you soon discover that your original choices where not optimal.

### Code 
You are given a framework which includes:
 * Location.java - describes a location using double values `x` and `y`
 * Job.java - describes a job generated by the alert system which monitors if the solar panels are generating electricity. A job object includes:
    * `Location location` - describes where the solar panel is located
    * `double time` - denotes the time when it was discovered that the solar panel stopped producing electricity
    * `int robotsNeeded` - denotes the number of robots required for cleaning the solar panel
 * Robot.java - represents a robot for cleaning. Set of methods controlling the robot:
    * `getLocation()` - get last known `Location` of the robot
    * `getJob` - get the current `Job` assigned to the robot
    * `move(Job job)` - assigns the `Job` to the robot. Robot moves towards the location of the job. Aborts any previous commands
    * `move(Location location)` - robots moves towards the given `Location` and awaits further orders. Aborts any previous commands

The package `INF102.Mandatory1.system` contains code for simulating the environment of robots and solar panels. **You do not have to look at this code**.

The package `INF102.Mandatory1.visualizer` is used to handle and vizualize the input for the system. Each file in the `input` folder contains location of robots and solar panels placed around the field. To visualize the input run `Visualizer.java`. You will see a screen of white and red dots. White dots are robots and red dots are jobs that need to be executed (solar panels that need cleaning). **HINT: Visualizing the input might help you devise your own strategy in task 2.3**.

## Tasks
Your job as consultant on the project is to devise a strategy for manuevering the robots around the field to allow the solar panels to generate the most amount of electricity over time. For this you must implement a set of strategies to manouver the robots. 

The interface `IStrategy` contains three methods which the system calls when a new cleaning job is detected.

Currently there is an abstract class `AbstractStrategy` which implements `IStrategy`. We have three strategy classes that extend `AbstractStrategy`: 
 - `RandomStrategy`: Select random robots to do the jobs.
 - `ClosestStrategy`: Select the robots who are closest to the current job.
 - `BetterStrategy`: Here you will device your own strategy.

**These classes have been created, but are missing the actual functionality of selecting robots.**

### Task 2.1
Implement the selection of robots in `RandomStrategy` and `ClosestStrategy` using your code from Task 1.1 and 1.2.

```java
@Override
public List<Robot> selectRobots(Job job) {
	throw new UnsupportedOperationException();
}
```

For `ClosestStrategy` you must pass a comparator as argument. For now you can simply pass `Comparator.naturalOrder()`.


✅ This task is implemented correctly when all tests in `RandomStrategyTest` passes, and <br></br>
✅ `returnEmptyListWhenNotEnoughRobots` and `selectCorrectAmountOfRobots` in `ClosestStrategyTest` passes, and <br></br>
✅ `TestClient.java` runs for `RandomStrategy` and `ClosestStrategy`. I.e. prints out a score for the input files (the question marks should be integer values):
```
-----Scores for Random strategy-----
Score input/01.in: ??????
Score input/02.in: ??????
Score input/03.in: ??????
Score input/04.in: ??????
Score input/05.in: ??????
Score input/06.in: ??????

-----Scores for Closest strategy-----
Score input/01.in: ??????
Score input/02.in: ??????
Score input/03.in: ??????
Score input/04.in: ??????
Score input/05.in: ??????
Score input/06.in: ??????

-----Scores for Better strategy-----
Better strategy is not implemented.
```

### Task 2.2
At the moment the comparator used when selecting the smallest elements in the robot list is comparing robots based on ID. The ID of the robot has no practical use when selecting which robots to do a job. It is essentially random at the moment. 

What you need to do is create a comparator which will order the robots based on the distance from a given job.<br></br>
**TODO: Create the class `ClosestComparator` which compares robots based on their distance to a given job.**

After you have implemented this comparator, swap it out in `ClosestStrategy`. Swap `Comparator.naturalOrder()` with your solution.

✅ Task 2.2 is correct when `ClosestStrategyTest` passes.


### Task 2.3 - BetterStrategy
*This task is more advanced than the previous once.*

Implement your own strategy: `BetterStrategy`. Apply all your algorithmic knowledge to best manouver the robots.

You are not supposed to develop an optimal algorithm for manouvering the robots. As long as all jobs are executed then we will approve the solution. A normal algorithm has correct and incorrect answers, but in this task you are to develop a heuristic. A heuristic has many answers, some better than others. The primary goal in this task is not to make your code fast, but to get as low numbers as possible when running `TestClient`.  

**HINT**: When implementing `BetterStrategy`, overriding existing methods in `AbstractStrategy` can give you a better performance.

`BetterStrategyTest` checks if `BetterStrategy` gives a better result than `RandomStrategy` and `ClosestStrategy`. Passing these tests does not mean that you will recieve full score for this task. Your goal is to recieve the lowest score possible on the simulation inputs. These values are printed when running `TestClient`.


## Grading
This mandatory assignment will count 15 % towards your final grade. You will recieve a score between 0 and 15.
The following rubric will be used to assess you assignemnt:

### Code Quality
Code quality gives 0-3 points.
 * The code must be clear and readable
 * Avoid repetition of code
 * Utilize concepts from INF101 to write maintainable and modular code

### Runtime Analysis (svar.md)
Runtime analysis gives 0-3 points. <br></br>
 * Every method you use must have a runtime analysis using Big-O notation. You get points if the runtime is correct, but a reduction in score if it is incorrect. Having no runtime analysis will yield zero points for that method.
 * The runtime analysis must be written in svar.md. In addition to Big-O notation you must add a description of why the method has this runtime.

**Section 1** <br></br>
The runtime should be expressed using two parameters:
   * `n` - number of elements in the list
   * `k` - number of elements to remove/find

**Section 2** <br></br>
The runtime should be expressed using three parameters
   * `m` - number of jobs in the simulation (input up to 1 000 000 can be expected)
   * `n` - number of robots in the simulation (input up to 100 can be expected)
   * `k` - number of robots required for a job (input up to 10 can be expected)

Note that not all of these parameters will be relevant to all methods. Some methods might just be dependent on one or two of the parameters.

### Functional and Efficient Algorithms and Datastructures
Correct and appropriate use of algorithms and datastructures gives 0-9 points.
The goal of this task is to write algorithms that both solve the problem yielding the best result possible, i.e. the solar panels produce as much electricity as possible, and the code runs as efficiently as possible. In this task you will need to use algorithms and datastructures you have learned in this course, for instance: `LinkedList`, `ArrayList`, `HashMap`, `PriorityQueue`, etc. We will look at every method you have implemented and assess if you have done this as efficiently as possible.
 * **Task 1.1 & 1.2** gives 0-3 points.
    * We will assess if your implementation is functionally correct
    * We will assess whether the methods and classes implemented to complete the task are written as efficiently as possible
 * **Task 2.1 & 2.2** gives 0-3 points.
    * We will assess if your implementation is functionally correct
    * We will assess whether the methods and classes implemented to complete the task are written as efficiently as possible
 * **Task 2.3** gives 0-3 points.
    * 1 point is given by outperforming ``RandomStrategy`` and ``ClosestStrategy`` on some inputs
    * 2 point is given much better than ``RandomStrategy`` and ``ClosestStrategy`` on most inputs
    * 3 points are given to the most efficient solutions
